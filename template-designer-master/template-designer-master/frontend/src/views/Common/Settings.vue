<template>
  <div
    class="mt-5 mr-2 ml-0"
    id="outer-tab"
    :class="outerTabArrowHidden ? 'ml-8' : ''"
  >
    <v-tabs
      center-active
      v-model="selectedTab"
      :class="{
        'ml-n2': !outerTabArrowHidden,
      }"
    >
      <v-tab
        v-for="item in applications"
        :key="item.key"
        @click="setActiveTab(item.name)"
        >{{ item.name }}</v-tab
      >
      <v-tab-item
        v-for="item in applications"
        :key="item.key"
        :class="{
          'mt-5': outerTabArrowHidden,
          'mt-5 ml-10 mr-5': item.key != 'Tasks' && !outerTabArrowHidden,
        }"
      >
        <div
          v-if="
            setting[item.key] &&
            !setting[item.key].settings &&
            item.key != 'Tasks'
          "
        >
          <v-row justify="center" class="mt-7 info-class pb-6"
            ><span>This application has no options to configure</span></v-row
          >
        </div>
        <div v-else-if="setting[item.key]" class="container">
          <v-card outlined class="pl-2 pt-0 pb-2" v-if="selectedTab == 0">
            <v-row>
              <v-col cols="3">
                <v-checkbox
                  dense
                  label="Apply Globally To All Editors"
                  v-model="
                    setting['CommonSettings'].settings.applyGloballyToAllEditors
                  "
                  @change="updateCommonsetting(item.key)"
                ></v-checkbox>
              </v-col>
              <v-col cols="9" class="mt-2">
                <span class="info-class">
                  Apply below settings on this tab to all applications.
                  Versioning is not applicable to all artifacts, so it will not
                  be applied.</span
                >
              </v-col>
            </v-row>
          </v-card>

          <!-- config for test application -->
          <v-card
            outlined
            class="mt-5 pl-2 pt-5 mb-5"
            v-if="item.name == 'Tests Editor'"
          >
            <v-row>
              <v-col cols="3">
                <v-text-field
                  dense
                  label="Integration Test Tag"
                  outlined
                  :rules="tagRules"
                  v-model="setting[item.key].settings.integrationTestTag"
                  @change="updateProjectSettings(item.key)"
                ></v-text-field>
                <v-text-field
                  dense
                  label="Verification Test Tag"
                  outlined
                  :rules="tagRules"
                  v-model="setting[item.key].settings.verificationTestTag"
                  @change="updateProjectSettings(item.key)"
                ></v-text-field>
                <v-text-field
                  dense
                  label="Validation Test Tag"
                  outlined
                  :rules="tagRules"
                  v-model="setting[item.key].settings.validationTestTag"
                  @change="updateProjectSettings(item.key)"
                ></v-text-field>
                <v-text-field
                  dense
                  label="Acceptance Test Tag"
                  outlined
                  :rules="tagRules"
                  v-model="setting[item.key].settings.acceptanceTestTag"
                  @change="updateProjectSettings(item.key)"
                ></v-text-field>
              </v-col>
              <v-col cols="9">
                <span class="info-class">
                  The test identifier tags used for traceability purpose for
                  each type of test document created by the application.
                </span>
                <span class="info-class">
                  <ul>
                    <li>
                      PRJ: Project identification code made using three
                      alphabets.
                    </li>

                    <li>
                      SYS: System identification code made using three
                      alphabets.
                    </li>

                    <li>INT-TST: Used for Integration test type.</li>
                    <li>VER-TST: Used for Verification test type.</li>

                    <li>VAL-TST: Used for Validation test type.</li>
                    <li>ACT-TST: Used for acceptance test type.</li>
                    <li>
                      NNN: A three digit number generated by the application in
                      sequence starting from 001, 002, 003 … 100, 101 … The
                      generated tag has the form PRJ-SYS-VAL-TST-007.
                    </li>
                  </ul>
                </span>
              </v-col>
            </v-row>
          </v-card>
          <!-- ends here -->

          <!-- config for taskman application -->
          <div v-if="item.name == 'Taskman'" class="mt-5">
            <v-row class="ml-6 mr-5">
              <span>Child Tasks Configuration</span>
              <v-spacer />
              <v-btn
                class="button white--text"
                @click="resetChildTasksForAllTaskTypes(item.key)"
                v-if="setting.Tasks.tasksList.length > 0"
                >Defaults</v-btn
              >
            </v-row>
            <v-row class="ml-6 mt-5">
              <span class="info-class"
                >Child task mapping defines a relation between tasks and
                controls the life cycle management of tasks. Use this feature to
                group and manage logically related tasks. It is not mandatory to
                define this relation if the parent child relation is not
                required. The tasks can still be linked.
              </span>
            </v-row>
            <div
              class="mt-5 ml-5"
              id="second-tab"
              :class="!arrowHidden ? 'ml-n6' : ''"
            >
              <v-tabs>
                <v-tab v-for="task in setting.Tasks.tasksList" :key="task.name">
                  {{ task.name }}
                </v-tab>
                <v-tab-item
                  v-for="task in setting.Tasks.tasksList"
                  :key="task.name"
                  :class="!arrowHidden ? 'ml-13' : ''"
                >
                  <v-row justify="end" class="mt-5 mr-5">
                    <v-btn
                      class="button white--text"
                      @click="resetChildTasks(task, item.key)"
                      >Defaults</v-btn
                    >
                  </v-row>
                  <v-card outlined class="mt-5 pl-2 pt-0 pb-2 mr-5">
                    <v-row>
                      <v-col cols="3">
                        <v-checkbox
                          dense
                          label="Allow Child Tasks"
                          v-model="task.isChildAllowed"
                          @change="updateTaskManSetting(item.key)"
                        ></v-checkbox>
                      </v-col>
                      <v-col cols="9" class="mt-2">
                        <span class="info-class">
                          Controls if artifacts produced by the applications are
                          versioned by default. All applications don't produce
                          artifacts which require versioning.</span
                        >
                      </v-col>
                    </v-row>
                  </v-card>
                  <v-card
                    outlined
                    class="mt-5 pl-2 pt-3 pb-2 mr-5"
                    v-if="task.isChildAllowed"
                  >
                    <v-row>
                      <v-col cols="3">
                        <v-select
                          :items="setting.Tasks.tasksList"
                          dense
                          outlined
                          label="Select Child Task"
                          :value="task.childTaskTypes"
                          :item-text="'name'"
                          multiple
                          @change="updateChildTasks(task, $event)"
                        >
                          <template v-slot:selection="{ item, index }">
                            <v-chip small v-if="index === 0" class="mt-2">
                              <span>{{ item.name }}</span>
                            </v-chip>
                            <span
                              v-if="index === 1"
                              class="grey--text text-caption mt-1"
                            >
                              (+{{ task.childTaskTypes.length - 1 }} others)
                            </span>
                          </template>
                        </v-select>
                      </v-col>
                      <v-col cols="9">
                        <span class="info-class">
                          When this property is set, this task can have child
                          tasks. A task can be associated to this task as a
                          child after creation.</span
                        >
                      </v-col>
                    </v-row>
                    <div v-if="task.childTaskTypes.length > 0">
                      <span>Selected Child Tasks</span>
                      <v-row class="ma-0 mt-2 mr-2 border-class">
                        <div
                          v-for="taskType in task.childTaskTypes"
                          :key="taskType"
                        >
                          <v-chip
                            small
                            class="ma-2"
                            close
                            @click:close="
                              removeLabelFromList(task.name, taskType, item.key)
                            "
                          >
                            {{ taskType }}
                          </v-chip>
                        </div>
                      </v-row>
                    </div>
                  </v-card>
                </v-tab-item>
              </v-tabs>
            </div>
          </div>
          <!-- ends here -->

          <!-- common setting -->
          <div
            v-if="
              setting['CommonSettings'].settings.applyGloballyToAllEditors &&
              selectedTab != 0
            "
            class="mt-2"
          >
            <span class="warn-class"
              >The options in this tab are disabled because “Apply Globally To
              All Editors” flag is set in the Common Settings tab. To enable the
              fields in this tab and customize Common Settings for this
              application, uncheck the “Apply Globally To All Editors” checkbox.
            </span>
          </div>
          <div
            :class="
              setting['CommonSettings'].settings.applyGloballyToAllEditors &&
              selectedTab != 0
                ? 'disable-div'
                : ''
            "
            v-if="
              item.name !== 'Taskman' &&
              item.name != 'Easy Kanban' &&
              item.name != 'White Board'
            "
          >
            <v-card
              outlined
              class="mt-5 pl-2 pt-0 pb-2"
              v-if="
                selectedTab == 0 ||
                item.name == 'Conops' ||
                item.name == 'Reports' ||
                item.name == 'Use Case' ||
                item.name == 'Requirements' ||
                item.name == 'Design' ||
                item.name == 'Template Designer' ||
                item.name == 'Tests Editor' ||
                item.name == 'Tests Recorder'
              "
            >
              <v-row>
                <v-col cols="3">
                  <v-checkbox
                    dense
                    label="Auto Lock Edit View"
                    v-model="item.lockEditViewAutomatically"
                    @change="updateUserSetting(item)"
                  ></v-checkbox>
                </v-col>
                <v-col cols="9" class="mt-2">
                  <span class="info-class">
                    When this property is applied, the applications which
                    dispose an edit view, will have the editor locked
                    automatically when the edit area is clicked. This is helpful
                    to prevent multiple editors of the same document/node
                    creating a mess and confusion.</span
                  >
                </v-col>
              </v-row>
            </v-card>

            <v-card outlined class="mt-5 pl-2 pt-4">
              <v-row>
                <v-col cols="3">
                  <v-text-field
                    dense
                    label="Auto Save Time(s)"
                    outlined
                    type="number"
                    min="1"
                    v-model="setting[item.key].settings.autoSaveTime"
                    @change="checkApplicationName(item.key)"
                  ></v-text-field>
                </v-col>
                <v-col cols="9">
                  <span class="info-class">
                    The time period after which auto-save operation saves the
                    work and updates content for other users working on the same
                    artifact.</span
                  >
                </v-col>
              </v-row>
            </v-card>
            <v-card
              outlined
              class="mt-5 pl-2 pt-4"
              v-if="item.name !== 'Cover Page Designer'"
            >
              <v-row>
                <v-col cols="3">
                  <v-text-field
                    dense
                    label="Undo Redo Count"
                    outlined
                    type="number"
                    min="1"
                    v-model="setting[item.key].settings.undoRedoCount"
                    @change="checkApplicationName(item.key)"
                  ></v-text-field>
                </v-col>
                <v-col cols="9">
                  <span class="info-class">
                    The number of undo-redo operations possible for an
                    application.</span
                  >
                </v-col>
              </v-row>
            </v-card>
            <v-card
              outlined
              class="mt-5 pl-2 pt-2 pb-3"
              v-if="item.name !== 'Cover Page Designer'"
            >
              <v-row>
                <v-col cols="3">
                  <v-checkbox
                    dense
                    label="Use Versioning"
                    v-model="setting[item.key].settings.useVersion"
                    @change="checkApplicationName(item.key)"
                  ></v-checkbox>
                </v-col>
                <v-col cols="9" class="mt-2">
                  <span class="info-class">
                    Controls if artifacts produced by the applications are
                    versioned by default. All applications don't produce
                    artifacts which require versioning.</span
                  >
                </v-col>
              </v-row>
            </v-card>
            <v-card
              outlined
              class="mt-5 pl-2 pt-2 pb-3"
              v-if="item.name !== 'Cover Page Designer'"
            >
              <v-row>
                <v-col cols="3">
                  <v-checkbox
                    dense
                    label="Commit Using Task"
                    v-model="setting[item.key].settings.commitUsingTask"
                    @change="checkApplicationName(item.key)"
                  ></v-checkbox>
                </v-col>
                <v-col cols="9" class="mt-2">
                  <span class="info-class">
                    Controls if commit operations for versioning require tasks.
                    When this variable is set, it is mandatory to provide a task
                    for commit operations, else commit operation cannot be
                    performed.</span
                  >
                </v-col>
              </v-row>
            </v-card>
          </div>
          <!-- ends here -->
        </div>
      </v-tab-item>
    </v-tabs>
    <UpdateSettingAcknowledgePopup ref="updateSetting" />
  </div>
</template>

<script>
import { mapActions, mapGetters } from "vuex";
import request from "../../utils/request";
import UpdateSettingAcknowledgePopup from "../../components/Common/UpdateSettingAcknowledgePopup.vue";
import helper from "../../utils/helper";

export default {
  components: {
    // GithubSettings,
    // GitlabSettings,
    UpdateSettingAcknowledgePopup,
    // TaskBoardSettings,
    // ErrorCard
  },
  data() {
    return {
      PageErrorData: {},
      selectedTab: 0,
      activeTab: "Taskman",
      applications: [
        {
          key: "CommonSettings",
          name: "Common Settings",
        },
      ],
      tasksList: [],
      tagRules: [
        (v) => {
          if (!v) return "Required";
          if (/[!@#$%^&*()+=[\]{};':"\\|,.<>/?_]+/.test(v))
            return "Project Name should not contain special Characters";
          if (v.includes(" "))
            return "Project Name should not contain whitespace.";
          return true;
        },
      ],
      setting: {},
      defaultChildTasks: {},
      arrowHidden: false,
      outerTabArrowHidden: false,
    };
  },
  async mounted() {
    this.setNavPath("Project Settings");
    const { projectId } = this.$route.params;
    this.setCurrentProject(projectId);
    this.getPageData();
    await this.getUserAccess();
    this.getProjectSettings();
    this.getUserSetting();
    if (!this.isDocReadOnly()) this.checkIfArrowHiddenForOuterTab();
  },
  methods: {
    ...mapGetters({
      getCurrentProject: "tree/getCurrentProject",
      currentUser: "getUser",
      isDocReadOnly: "tree/isDocReadOnly",
    }),
    ...mapActions({
      setSnackbar: "snackbar/setSnackbar",
      setCurrentProject: "tree/setCurrentProject",
      setNavPath: "modal/setNavPath",
    }),
    ...mapActions(["checkUserAccessForApplication"]),
    async getCurrentAppsetting() {
      const project = await this.getCurrentProject();
      let applicationSetting = helper.getAppSettingForApplication(project);
      return applicationSetting;
    },
    async getUserAccess() {
      const applicationSetting = await this.getCurrentAppsetting();
      const applicationName = applicationSetting.name;
      const { projectId } = this.$route.params;
      const data = {
        projectId: projectId,
        applicationName: applicationName,
        navPath: "Setting",
      };
      await this.checkUserAccessForApplication(data);
    },
    async getPageData() {
      const { projectId } = this.$route.params;
      const currentUserRole = await helper.getCurrentUserRole(projectId);
      this.PageErrorData = {
        breadCrumb: "Warning",
        icon: "mdi-alert-outline",
        color: "orange",
        errorMessage: "",
        infoMessage: `Your role as ${currentUserRole} does not have access to creation. Contact the administrator to get access.`,
      };
    },
    async getUserSetting() {
      const email = this.currentUser().email;
      const response = await request({
        url: `/user/fetch/one/${email}`,
        method: "get",
      });
      if (response.data && response.data.lockEditViewAutomatically) {
        const data = response.data.lockEditViewAutomatically;
        for (var key in data) {
          const index = this.applications.findIndex((app) => app.key == key);
          if (index != -1) {
            this.applications[index].lockEditViewAutomatically = data[key];
          }
        }
      }
      if (
        response.data &&
        response.data.lockEditViewAutomatically == undefined
      ) {
        var appNames = [];
        const value = false;
        this.applications.forEach((app) => {
          if (app.lockEditViewAutomatically != undefined)
            appNames.push(app.key);
        });
        const email = this.currentUser().email;
        await request({
          url: `/user/update/lock/${email}`,
          body: { appNames: appNames, value: value },
          method: "put",
        });
      }
    },
    getProjectSettings() {
      const project = this.getCurrentProject();
      this.setting = project.appSettings;
      this.applications[0].lockEditViewAutomatically =
        this.setting["CommonSettings"].settings.lockEditViewAutomatically;
      this.defaultChildTasks = this.setting.tasksInfo.defaultChildTasks;
      this.filterInstalledApplications();
    },
    setActiveTab(name) {
      this.activeTab = name;
      if (this.activeTab == "Taskman") {
        setTimeout(() => {
          this.checkIfArrowHidden();
        }, 200);
      }
    },
    checkIfArrowHiddenForOuterTab() {
      setTimeout(() => {
        const nextEle = document
          .getElementById("outer-tab")
          .getElementsByClassName("v-slide-group__next--disabled");
        const prevEle = document
          .getElementById("outer-tab")
          .getElementsByClassName("v-slide-group__prev--disabled");
        if (nextEle.length > 0 && prevEle.length > 0)
          this.outerTabArrowHidden = true;
        else this.outerTabArrowHidden = false;
      }, 100);
    },
    checkIfArrowHidden() {
      const nextEle = document
        .getElementById("second-tab")
        .getElementsByClassName("v-slide-group__next--disabled");
      const prevEle = document
        .getElementById("second-tab")
        .getElementsByClassName("v-slide-group__prev--disabled");
      if (nextEle.length > 0 && prevEle.length > 0) this.arrowHidden = true;
      else this.arrowHidden = false;
    },
    filterInstalledApplications() {
      const installedApllications = this.setting.applications;
      for (var key in this.setting) {
        if (key != undefined && key != "") {
          const data = this.setting[key];
          if (data.name && installedApllications.indexOf(data.name) != -1) {
            const appObj = {
              key: key,
              name: data.name,
            };
            if (
              data.userProfileSettings &&
              data.userProfileSettings.lockEditViewAutomatically != undefined
            )
              appObj.lockEditViewAutomatically =
                data.userProfileSettings.lockEditViewAutomatically;
            this.applications.push(appObj);
          }
        }
      }
      if (this.setting.Tasks) this.getDefaultSettingForTaskMan();
    },
    getDefaultSettingForTaskMan() {
      var initialLoad = false;
      this.setting.Tasks.tasksList.forEach((task) => {
        if (
          task.isChildAllowed == undefined ||
          task.childTaskTypes == undefined
        ) {
          initialLoad = true;
          if (task.isChildAllowed == undefined) task.isChildAllowed = false;
          if (task.childTaskTypes == undefined) {
            task.childTaskTypes = [];
            if (this.defaultChildTasks[task.name]) {
              this.defaultChildTasks[task.name].forEach((type) => {
                const index = this.setting.Tasks.tasksList.findIndex(
                  (data) => data.name == type
                );
                if (index != -1) task.childTaskTypes.push(type);
              });
            }
          }
        }
      });
      if (initialLoad) {
        this.setting.Tasks.tasksList.forEach((task) => {
          const parentTask = task;
          this.setting.Tasks.tasksList.forEach((childTask) => {
            if (parentTask.childTaskTypes.indexOf(childTask.name) != -1) {
              if (childTask.parentTaskTypes) {
                childTask.parentTaskTypes.push(parentTask.name);
              } else childTask.parentTaskTypes = [parentTask.name];
            }
          });
        });
        this.updateTaskManSetting("Tasks");
      }
    },
    removeLabelFromList(taskType, childTask, appName) {
      this.setting.Tasks.tasksList.forEach((task) => {
        if (task.name == taskType) {
          const index = task.childTaskTypes.indexOf(childTask);
          if (index != -1) {
            // Removing linked parent task
            const childTaskIndex = this.setting.Tasks.tasksList.findIndex(
              (task) => task.name == childTask
            );
            const childTaskType = this.setting.Tasks.tasksList[childTaskIndex];
            const parentTaskIndex =
              childTaskType.parentTaskTypes.indexOf(taskType);
            if (parentTaskIndex != -1) {
              childTaskType.parentTaskTypes.splice(parentTaskIndex, 1);
              this.setting.Tasks.tasksList[childTaskIndex] = childTaskType;
            }
            // ends here

            task.childTaskTypes.splice(index, 1);
            this.updateProjectSettings(appName);
          }
        }
      });
    },
    resetChildTasksForAllTaskTypes(appName) {
      this.setting.Tasks.tasksList.forEach((task) => {
        // Updating patent task types
        const parentTask = task;
        this.setting.Tasks.tasksList.forEach((childTask) => {
          var updatedChildTasks = [];
          if (this.defaultChildTasks[parentTask.name]) {
            this.defaultChildTasks[parentTask.name].forEach((type) => {
              const index = this.setting.Tasks.tasksList.findIndex(
                (data) => data.name == type
              );
              if (index != -1) updatedChildTasks.push(type);
            });
          }
          var newChildTasks = updatedChildTasks.filter((task) => {
            return parentTask.childTaskTypes.indexOf(task) == -1;
          });
          var removeChildTasks = parentTask.childTaskTypes.filter((task) => {
            return updatedChildTasks.indexOf(task) == -1;
          });

          if (newChildTasks.indexOf(childTask.name) != -1) {
            if (childTask.parentTaskTypes) {
              childTask.parentTaskTypes.push(parentTask.name);
            } else {
              childTask.parentTaskTypes = [parentTask.name];
            }
          }
          if (removeChildTasks.indexOf(childTask.name) != -1) {
            const index = childTask.parentTaskTypes.indexOf(parentTask.name);
            if (index != -1) childTask.parentTaskTypes.splice(index, 1);
          }
        });
        // ends here

        task.isChildAllowed = false;
        task.childTaskTypes = [];
        if (this.defaultChildTasks[task.name]) {
          this.defaultChildTasks[task.name].forEach((type) => {
            const index = this.setting.Tasks.tasksList.findIndex(
              (data) => data.name == type
            );
            if (index != -1) task.childTaskTypes.push(type);
          });
        }
      });
      this.updateProjectSettings(appName);
    },
    resetChildTasks(parentTask, appName) {
      var updatedChildTasks = [];
      if (this.defaultChildTasks[parentTask.name]) {
        this.defaultChildTasks[parentTask.name].forEach((type) => {
          const index = this.setting.Tasks.tasksList.findIndex(
            (data) => data.name == type
          );
          if (index != -1) updatedChildTasks.push(type);
        });
      }
      var newChildTasks = updatedChildTasks.filter((task) => {
        return parentTask.childTaskTypes.indexOf(task) == -1;
      });
      var removeChildTasks = parentTask.childTaskTypes.filter((task) => {
        return updatedChildTasks.indexOf(task) == -1;
      });
      this.setting.Tasks.tasksList.forEach((task) => {
        // Updating patent task types
        if (newChildTasks.indexOf(task.name) != -1) {
          if (task.parentTaskTypes) {
            task.parentTaskTypes.push(parentTask.name);
          } else {
            task.parentTaskTypes = [parentTask.name];
          }
        }
        if (removeChildTasks.indexOf(task.name) != -1) {
          const index = task.parentTaskTypes.indexOf(parentTask.name);
          if (index != -1) task.parentTaskTypes.splice(index, 1);
        }
        // ends here

        if (task.name == parentTask.name) {
          task.isChildAllowed = false;
          task.childTaskTypes = [];
          if (this.defaultChildTasks[task.name]) {
            this.defaultChildTasks[task.name].forEach((type) => {
              const index = this.setting.Tasks.tasksList.findIndex(
                (data) => data.name == type
              );
              if (index != -1) task.childTaskTypes.push(type);
            });
          }
        }
      });
      this.updateProjectSettings(appName);
    },
    updateChildTasks(parentTask, event) {
      const newChildTasks = event.filter((task) => {
        return parentTask.childTaskTypes.indexOf(task) == -1;
      });
      const removeChildTasks = parentTask.childTaskTypes.filter((task) => {
        return event.indexOf(task) == -1;
      });
      this.setting.Tasks.tasksList.forEach((task) => {
        if (newChildTasks.indexOf(task.name) != -1) {
          if (task.parentTaskTypes) {
            task.parentTaskTypes.push(parentTask.name);
          } else {
            task.parentTaskTypes = [parentTask.name];
          }
        }
        if (removeChildTasks.indexOf(task.name) != -1) {
          const index = task.parentTaskTypes.indexOf(parentTask.name);
          if (index != -1) task.parentTaskTypes.splice(index, 1);
        }
      });
      this.setting.Tasks.tasksList.forEach((task) => {
        if (task.name == parentTask.name) task.childTaskTypes = event;
      });
      this.updateProjectSettings("Tasks");
    },
    async updateUserSetting(data) {
      var appNames = [];
      var value;
      if (data.key == "CommonSettings") {
        //From UpdateCommonsettings method
        if (
          data.settings &&
          data.settings.lockEditViewAutomatically != undefined
        ) {
          this.setting["CommonSettings"].settings.lockEditViewAutomatically =
            data.settings.lockEditViewAutomatically;
          value = data.settings.lockEditViewAutomatically;
        }

        // From autolock checkbox of common settings.
        if (data.lockEditViewAutomatically != undefined) {
          this.setting["CommonSettings"].settings.lockEditViewAutomatically =
            data.lockEditViewAutomatically;
          value = data.lockEditViewAutomatically;
        }
        await this.updateProjectSettings(data.key, false);
        if (this.setting["CommonSettings"].settings.applyGloballyToAllEditors) {
          this.applications.forEach((app) => {
            if (app.lockEditViewAutomatically != undefined) {
              appNames.push(app.key);
            }
          });
        }
      } else {
        value = data.lockEditViewAutomatically;
        appNames = [data.key];
      }
      if (appNames.length > 0) {
        const email = this.currentUser().email;
        const response = await request({
          url: `/user/update/lock/${email}`,
          body: {
            appNames: appNames,
            value: value,
          },
          method: "put",
        });
        if (response.data && response.data.success) {
          this.setSnackbar({
            message: "Auto Saved",
            color: "green",
            timeout: 1000,
          });
          this.getUserSetting();
        } else {
          this.setSnackbar({ message: "Some error occured", color: "red" });
        }
      }
    },
    async updateTaskManSetting(appName) {
      await this.updateProjectSettings(appName);
      this.$forceUpdate();
    },
    async checkApplicationName(appName) {
      if (
        appName == "CommonSettings" &&
        this.setting[appName].settings.applyGloballyToAllEditors
      )
        this.updateCommonsetting(appName);
      else await this.updateProjectSettings(appName);
    },
    updateCommonsetting(name) {
      if (this.setting[name].settings.applyGloballyToAllEditors) {
        for (var key in this.setting) {
          if (key != "CommonSettings") {
            if (this.setting[key].settings) {
              if (this.setting[key].settings.autoSaveTime)
                this.setting[key].settings.autoSaveTime =
                  this.setting[name].settings.autoSaveTime;
              if (this.setting[key].settings.undoRedoCount)
                this.setting[key].settings.undoRedoCount =
                  this.setting[name].settings.undoRedoCount;
              if (this.setting[key].settings.useVersion != undefined)
                this.setting[key].settings.useVersion =
                  this.setting[name].settings.useVersion;
              if (this.setting[key].settings.commitUsingTask != undefined)
                this.setting[key].settings.commitUsingTask =
                  this.setting[name].settings.commitUsingTask;
              this.updateProjectSettings(key, false);
            }
          }
        }
      }
      var appData = {};
      for (var val in this.setting) {
        if (val == "CommonSettings") {
          appData = this.setting[val];
          appData.key = "CommonSettings";
        }
      }
      this.updateUserSetting(appData);
    },
    async updateProjectSettings(appName, showMessage) {
      const { projectId } = this.$route.params;
      const configData = this.setting[appName];
      const response = await request({
        url: `/project/update/${projectId}/${appName}`,
        body: { projectSettingsData: configData },
        method: "put",
      });
      if (response.data && response.data.success) {
        if (showMessage != false)
          this.setSnackbar({
            message: "Auto Saved",
            color: "green",
            timeout: 1000,
          });
        var projects = JSON.parse(localStorage.getItem("projects"));
        for (var i in projects) {
          if (projects[i].id == projectId) {
            projects[i].appSettings[appName] = this.setting[appName];
          }
        }
        const projectData = projects.map((project) => ({
          id: project.id,
          refId: project.refId,
          name: project.name,
          state: project.state,
          code: project.code,
          appSettings: project.appSettings,
        }));
        localStorage.setItem("projects", JSON.stringify(projectData));
      } else {
        this.setSnackbar({ message: "Some error occured", color: "red" });
      }
    },
  },
};
</script>

<style scoped>
.info-class {
  color: rgba(0, 0, 0, 0.6);
}
.warn-class {
  color: orange;
}
.error-class {
  color: red;
}
.border-class {
  border: 1px solid lightgray;
}
.disable-div {
  pointer-events: none;
  opacity: 0.8;
}
.container {
  height: 450px;
  overflow: auto;
}
</style>